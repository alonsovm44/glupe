/* GLUPE COMPILER ( formerly yori.exe) - v5.8*/

// build with this: g++ glupec.cpp -o glupe -std=c++17 -lstdc++fs -static-libgcc -static-libstdc++
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <stringstream>
#include <array>
#include <cstdio>
#include <cstdlib>
#include <thread>
#include <chrono>
#include <map>
#include <algorithm>
#include <iomanip>
#include <filesystem>
#include <ctime>
#include <functional>
#include <set>
#include <memory>
#include <limits>

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#else
#include <unistd.h>
#include <limits.h>
#endif

#ifndef _WIN32
#define _popen popen
#define _pclose pclose
#endif

#include "json.hpp"

using json = nlohmann::json;
using namespace std;
namespace fs = std::filesystem;

// --- CONFIGURATION ---
string PROVIDER = "local";
string PROTOCOL = "ollama"; // 'google', 'openai', 'ollama'
string API_KEY = "";
string MODEL_ID = "";
string API_URL = "";
int MAX_RETRIES = 15;
bool VERBOSE_MODE = false;

const string CURRENT_VERSION = "5.8.0";

enum class GenMode { CODE, MODEL_3D, IMAGE };
GenMode CURRENT_MODE = GenMode::CODE;

// --- LOGGER SYSTEM ---
ofstream logFile;

void initLogger() {
    $$ open_log_file { Open 'glupe.log' in append mode, initialize session header with version and timestamp } $$
}

void log(string level, string message) {
    $$ log_message { 
        Check if log file is open, append timestamped log entry with specified level, 
        optionally print to console if VERBOSE_MODE is enabled 
    } $$
}

// --- UTILS DECLARATION ---
struct CmdResult { string output; int exitCode; };

CmdResult execCmd(string cmd) {
    $$ execute_command { 
        Execute shell command with error redirection, capture output, return result with exit code 
    } $$
}

string stripExt(string fname) {
    $$ strip_extension { Extract filename without extension } $$
}

string getExt(string fname) {
    $$ get_extension { Extract file extension } $$
}

// [UPDATED v5.1] Enhanced error detection for lazy transpilation
bool isFatalError(const string& errMsg) {
    $$ detect_fatal_error { 
        Check error message for known fatal patterns (missing files, undefined references, etc.) 
        and AI-related issues (missing headers) 
    } $$
}

// [NEW] Helper for ETA formatting
string formatDuration(long long seconds) {
    $$ format_duration { Convert seconds to human-readable MM:SS format } $$
}

// --- LANGUAGE SYSTEM ---
struct LangProfile {
    string id; string name; string extension;
    string versionCmd; string buildCmd; bool producesBinary;
    string checkCmd;
};

map<string, LangProfile> LANG_DB = { /* ... */ };
map<string, LangProfile> MODEL_DB = { /* ... */ };
map<string, LangProfile> IMAGE_DB = { /* ... */ };

LangProfile CURRENT_LANG;

// --- CONFIG & TOOLCHAIN OVERRIDES ---
bool loadConfig(string mode) {
    $$ load_configuration { 
        Load config.json, apply settings for specified mode (local/cloud), 
        override toolchains if specified, handle errors 
    } $$
}

// --- AI CORE ---
string callAI(string prompt) {
    $$ ai_request { 
        Construct API request based on protocol (Google, OpenAI, Ollama), 
        handle retries, parse response, extract content 
    } $$
}

string extractCode(string jsonResponse) {
    $$ extract_code { 
        Parse JSON response, handle errors, extract code block from Markdown or raw text 
    } $$
}

void explainFatalError(const string& errorMsg) {
    $$ explain_error { 
        Query AI for solution to fatal error, display advice to user 
    } $$
}

// --- CONFIG COMMANDS ---
void updateConfigFile(string key, string value) {
    $$ update_config { 
        Load config.json, update specified key, save changes, handle validation 
    } $$
}

void showConfig() {
    $$ show_config { 
        Load and display current configuration settings 
    } $$
}

void selectOllamaModel() {
    $$ select_ollama_model { 
        Fetch available Ollama models, display options, allow user selection, update config 
    } $$
}
$$ openApiKeyPage { cout << "[INFO] Opening ApiFreeLlm.com..." << endl; #ifdef _WIN32 system("start https://apifreellm.com/en/api-access"); #else system("xdg-open https://apifreellm.com/en/api-access"); #endif } $$

$$ performTreeShaking { cout << "   [OPTIMIZE] Tree shaking (removing unused code)..." << endl; stringstream prompt; prompt << "ROLE: Senior Code Optimizer.\nTASK: Analyze the following " << language << " code and remove UNUSED functions, variables, and imports.\nRULES:\n1. Keep the 'main' function (or entry point) and everything it uses (transitively).\n2. Keep all 'EXPORT:' directives and file structures intact.\n3. Remove dead code that is never called or referenced.\n4. Do not change logic, only remove unused elements.\n5. Return ONLY the cleaned code.\nCODE:\n" << code << "\n"; string response = callAI(prompt.str()); string cleaned = extractCode(response); if (code.find("EXPORT:") != string::npos && cleaned.find("EXPORT:") == string::npos) { cout << "   [WARN] Tree shaking corrupted file structure (lost EXPORTs). Reverting." << endl; return code; } return (cleaned.find("ERROR:") == 0) ? code : cleaned; } $$

$$ resolveImports { stringstream ss(code); string line; string processed; while (getline(ss, line)) { string cleanLine = line; size_t first = cleanLine.find_first_not_of(" \t\r\n"); if (first == string::npos) { processed += line + "\n"; continue; } cleanLine.erase(0, first); if (cleanLine.rfind("IMPORT:", 0) == 0) { string fname = cleanLine.substr(7); size_t q1 = fname.find_first_of("\"'"); size_t q2 = fname.find_last_of("\"'"); if (q1 != string::npos && q2 != string::npos && q2 > q1) fname = fname.substr(q1 + 1, q2 - q1 - 1); else { fname.erase(0, fname.find_first_not_of(" \t\r\n\"'")); size_t last = fname.find_last_not_of(" \t\r\n\"'"); if (last != string::npos) fname.erase(last + 1); } fs::path path = basePath / fname; try { if (fs::exists(path)) { string absPath = fs::canonical(path).string(); bool cycle = false; for(const auto& s : stack) if(s == absPath) cycle = true; if (cycle) { processed += "// [ERROR] CYCLIC IMPORT DETECTED: " + fname + "\n"; log("ERROR", "Circular import: " + fname); } else { ifstream imp(path); if (imp.is_open()) { string content((istreambuf_iterator<char>(imp)), istreambuf_iterator<char>()); stack.push_back(absPath); string nested = resolveImports(content, path.parent_path(), stack); stack.pop_back(); string ext = path.extension().string(); processed += "\n// >>>>>> START MODULE: " + fname + " (" + ext + ") >>>>>>\n"; processed += nested; processed += "\n// <<<<<< END MODULE: " + fname + " <<<<<<\n"; log("INFO", "Imported module: " + fname); } } } else { processed += "// [WARN] IMPORT NOT FOUND: " + fname + "\n"; } } catch (...) { processed += "// [ERROR] PATH EXCEPTION\n"; } } else { processed += line + "\n"; } } return processed; } $$

$$ initCache { if (!fs::exists(CACHE_DIR)) fs::create_directory(CACHE_DIR); if (fs::exists(LOCK_FILE)) { try { ifstream f(LOCK_FILE); LOCK_DATA = json::parse(f); } catch(...) { LOCK_DATA = json::object(); } } else { LOCK_DATA = json::object(); LOCK_DATA["containers"] = json::object(); } } $$

$$ saveCache { ofstream f(LOCK_FILE); f << LOCK_DATA.dump(4); } $$

$$ getContainerHash { hash<string> hasher; return to_string(hasher(prompt)); } $$

$$ getCachedContent { string path = CACHE_DIR + "/" + id + ".txt"; if (fs::exists(path)) { ifstream f(path); return string((istreambuf_iterator<char>(f)), istreambuf_iterator<char>()); } return ""; } $$

$$ setCachedContent { string path = CACHE_DIR + "/" + id + ".txt"; ofstream f(path); f << content; } $$

$$ processInputWithCache { string result; map<string, string> containerPrompts; size_t pos = 0; while (pos < code.length()) { size_t start = code.find("$$", pos); if (start == string::npos) { result += code.substr(pos); break; } bool isNamed = false; bool isAbstract = false; string id; string parentId; size_t contentStart = 0; size_t scan = start + 2; while(scan < code.length() && isspace(code[scan])) scan++; if (scan + 8 <= code.length() && code.compare(scan, 8, "ABSTRACT") == 0 && (scan + 8 == code.length() || isspace(code[scan+8]))) { isAbstract = true; scan += 8; while(scan < code.length() && isspace(code[scan])) scan++; } if (scan < code.length() && code[scan] != '{') { size_t idStart = scan; while(scan < code.length() && !isspace(code[scan]) && code[scan] != '{' && !(code[scan] == '-' && scan+1 < code.length() && code[scan+1] == '>')) { scan++; } if (scan > idStart) { id = code.substr(idStart, scan - idStart); size_t brace = scan; while(brace < code.length() && isspace(code[brace])) brace++; if (brace + 1 < code.length() && code[brace] == '-' && code[brace+1] == '>') { size_t pScan = brace + 2; while(pScan < code.length() && isspace(code[pScan])) pScan++; size_t pStart = pScan; while(pScan < code.length() && !isspace(code[pScan]) && code[pScan] != '{') { pScan++; } if (pScan > pStart) { parentId = code.substr(pStart, pScan - pStart); brace = pScan; } } while(brace < code.length() && isspace(code[brace])) brace++; if (brace < code.length() && code[brace] == '{') { isNamed = true; contentStart = brace + 1; } } } if (isNamed) { size_t end = code.find("}$$", contentStart); if (end == string::npos) { result += code.substr(pos, start - pos + 2); pos = start + 2; continue; } string prompt = code.substr(contentStart, end - contentStart); if (!parentId.empty()) { if (containerPrompts.count(parentId)) { string parentLogic = containerPrompts[parentId]; string childLogic = prompt; prompt = "INHERITED FROM " + parentId + ":\n" + parentLogic + "\n\nCHILD LOGIC:\n" + childLogic; cout << "   [INHERIT] Container '" << id << "' inherits from '" << parentId << "'" << endl; } else { cout << "   [WARN] Parent container '" << parentId << "' not found (must be defined before use)." << endl; } } containerPrompts[id] = prompt; if (isAbstract) { cout << "   [ABSTRACT] Defined container: " << id << endl; result += code.substr(pos, start - pos); result += "// [ABSTRACT: " + id + "]\n"; pos = end + 3; continue; } string currentHash = getContainerHash(prompt); result += code.substr(pos, start - pos); bool cacheHit = false; bool skipUpdate = false; if (useCache && !updateTargets.empty()) { bool isTarget = false; for(const auto& t : updateTargets) if(t == id) isTarget = true; if (!isTarget) skipUpdate = true; } if (useCache && (skipUpdate || LOCK_DATA["containers"].contains(id))) { if (skipUpdate) { string content = getCachedContent(id); if (!content.empty()) { cout << "   [SKIP] Keeping container: " << id << endl; result += "\n// GLUPE_BLOCK_START: " + id + "\n"; result += content; result += "\n// GLUPE_BLOCK_END: " + id + "\n"; cacheHit = true; } else { cout << "   [WARN] Cache missing for skipped container: " << id << ". Regenerating." << endl; } } else if (LOCK_DATA["containers"].contains(id)) { string storedHash = LOCK_DATA["containers"][id]["hash"]; if (storedHash == currentHash) { string content = getCachedContent(id); if (!content.empty()) { cout << "   [CACHE] Using cached container: " << id << endl; result += "\n// GLUPE_BLOCK_START: " + id + "\n"; result += content; result += "\n// GLUPE_BLOCK_END: " + id + "\n"; cacheHit = true; } } } } if (!cacheHit) { result += "\n// GLUPE_BLOCK_START: " + id + "\n"; result += prompt; result += "\n// GLUPE_BLOCK_END: " + id + "\n"; LOCK_DATA["containers"][id]["hash"] = currentHash; LOCK_DATA["containers"][id]["last_run"] = time(nullptr); } pos = end + 3; } else { result += code.substr(pos, start - pos + 2); pos = start + 2; } } return result; } $$

$$ updateCacheFromOutput { string cleanCode; size_t pos = 0; while (pos < code.length()) { size_t start = code.find("// GLUPE_BLOCK_START: ", pos); if (start == string::npos) { cleanCode += code.substr(pos); break; } cleanCode += code.substr(pos, start - pos); size_t idStart = start + 21; size_t idEnd = code.find('\n', idStart); if (idEnd == string::npos) break; string id = code.substr(idStart, idEnd - idStart); id.erase(0, id.find_first_not_of(" \t\r")); id.erase(id.find_last_not_of(" \t\r") + 1); size_t blockEnd = code.find("// GLUPE_BLOCK_END: " + id, idEnd); if (blockEnd == string::npos) { cleanCode += code.substr(start); break; } string content = code.substr(idEnd + 1, blockEnd - (idEnd + 1)); setCachedContent(id, content); cout << "   [CACHE] Updated container: " << id << endl; cleanCode += content; size_t markerEnd = code.find('\n', blockEnd); pos = (markerEnd == string::npos) ? code.length() : markerEnd + 1; } saveCache(); return cleanCode; } $$

$$ stripTemplates { string result; size_t pos = 0; if (insideTemplate) { size_t end = line.find("}$$"); if (end != string::npos) { pos = end + 3; insideTemplate = false; } else { return ""; } } while (pos < line.length()) { size_t start = line.find("$$", pos); if (start == string::npos) { result += line.substr(pos); break; } bool isContainer = false; size_t contentStart = 0; if (start + 2 < line.length() && line[start+2] == '{') { isContainer = true; contentStart = start + 3; } else { size_t scan = start + 2; while(scan < line.length() && isspace(line[scan])) scan++; if (scan + 8 <= line.length() && line.compare(scan, 8, "ABSTRACT") == 0 && (scan + 8 == line.length() || isspace(line[scan+8]))) { scan += 8; while(scan < line.length() && isspace(line[scan])) scan++; } if (scan < line.length() && line[scan] != '{') { while(scan < line.length() && !isspace(line[scan]) && line[scan] != '{' && !(line[scan] == '-' && scan+1 < line.length() && line[scan+1] == '>')) { scan++; } size_t brace = scan; while(brace < line.length() && isspace(line[brace])) brace++; if (brace + 1 < line.length() && line[brace] == '-' && line[brace+1] == '>') { size_t pScan = brace + 2; while(pScan < line.length() && isspace(line[pScan])) pScan++; while(pScan < line.length() && !isspace(line[pScan]) && line[pScan] != '{') { pScan++; } brace = pScan; } while(brace < line.length() && isspace(line[brace])) brace++; if (brace < line.length() && line[brace] == '{') { isContainer = true; contentStart = brace + 1; } } } if (isContainer) { if (start > pos) { result += line.substr(pos, start - pos); } size_t end = line.find("}$$", contentStart); if (end == string::npos) { insideTemplate = true; break; } pos = end + 3; } else { result += line.substr(pos, start - pos + 2); pos = start + 2; } } return result; } $$

$$ parseBlueprint { vector<BlueprintEntry> entries; stringstream ss(fullContext); string line; BlueprintEntry current; bool inBlock = false; while (getline(ss, line)) { if (line.find("// --- START FILE:") == 0 || line.find("// --- END FILE:") == 0) continue; string cleanLine = line; size_t first = cleanLine.find_first_not_of(" \t\r\n"); if (first == string::npos) { if (inBlock) current.content += line + "\n"; continue; } cleanLine.erase(0, first); if (cleanLine.rfind("EXPORT:", 0) == 0) { if (inBlock && !current.filename.empty()) { entries.push_back(current); } current = BlueprintEntry(); string rawArgs = cleanLine.substr(7); size_t q1 = rawArgs.find_first_of("\"'"); if (q1 != string::npos) { char quote = rawArgs[q1]; size_t q2 = rawArgs.find(quote, q1 + 1); if (q2 != string::npos) current.filename = rawArgs.substr(q1 + 1, q2 - q1 - 1); } else { stringstream fss(rawArgs); fss >> current.filename; } inBlock = (current.filename != "END" && !current.filename.empty()); } else { if (inBlock) current.content += line + "\n"; } } if (inBlock && !current.filename.empty()) entries.push_back(current); return entries; } $$

$$ validateContainers { set<string> ids; size_t pos = 0; while ((pos = code.find("$$", pos)) != string::npos) { if (pos + 2 < code.length() && code[pos+2] == '{') { pos += 3; continue; } size_t scan = pos + 2; while(scan < code.length() && isspace(code[scan])) scan++; if (scan + 8 <= code.length() && code.compare(scan, 8, "ABSTRACT") == 0 && (scan + 8 == code.length() || isspace(code[scan+8]))) { scan += 8; while(scan < code.length() && isspace(code[scan])) scan++; } if (scan < code.length() && code[scan] != '{') { size_t idStart = scan; while(scan < code.length() && !isspace(code[scan]) && code[scan] != '{' && !(code[scan] == '-' && scan+1 < code.length() && code[scan+1] == '>')) { scan++; } if (scan > idStart) { string id = code.substr(idStart, scan - idStart); size_t brace = scan; while(brace < code.length() && isspace(code[brace])) brace++; if (brace + 1 < code.length() && code[brace] == '-' && code[brace+1] == '>') { size_t pScan = brace + 2; while(pScan < code.length() && isspace(code[pScan])) pScan++; while(pScan < code.length() && !isspace(code[pScan]) && code[pScan] != '{') { pScan++; } brace = pScan; } while(brace < code.length() && isspace(code[brace])) brace++; if (brace < code.length() && code[brace] == '{') { if (ids.count(id)) { cerr << "[ERROR] Duplicate container ID found: \"" << id << "\"" << endl; return false; } ids.insert(id); pos = brace + 1; continue; } } } pos += 2; } return true; } $$

$$ processExports { stringstream ss(code); string line; unique_ptr<ofstream> outFile; string remaining; bool exportError = false; bool insideTemplate = false; while (getline(ss, line)) { string cleanLine = line; size_t first = cleanLine.find_first_not_of(" \t\r\n"); if (first == string::npos) { if (outFile && outFile->is_open()) *outFile << "\n"; else if (!exportError) remaining += line + "\n"; continue; } cleanLine.erase(0, first); if (cleanLine.rfind("EXPORT:", 0) == 0) { outFile.reset(); exportError = false; insideTemplate = false; string rawArgs = cleanLine.substr(7); string fname; string sameLineCode; size_t q1 = rawArgs.find_first_of("\"'"); if (q1 != string::npos) { char quote = rawArgs[q1]; size_t q2 = rawArgs.find(quote, q1 + 1); if (q2 != string::npos) { fname = rawArgs.substr(q1 + 1, q2 - q1 - 1); if (q2 + 1 < rawArgs.length()) { sameLineCode = rawArgs.substr(q2 + 1); } } else { fname = rawArgs.substr(q1 + 1); } } else { stringstream fss(rawArgs); fss >> fname; size_t fPos = rawArgs.find(fname); if (fPos != string::npos) { size_t afterFname = fPos + fname.length(); if (afterFname < rawArgs.length()) sameLineCode = rawArgs.substr(afterFname); } } fname.erase(0, fname.find_first_not_of(" \t\r\n")); size_t last = fname.find_last_not_of(" \t\r\n"); if (last != string::npos) fname.erase(last + 1); if (fname.empty() || fname == "END") { continue; } fs::path path = basePath / fname; try { if (path.has_parent_path()) { if (!fs::exists(path.parent_path())) cout << "[EXPORT] Creating directory: " << path.parent_path().string() << endl; fs::create_directories(path.parent_path()); } outFile = make_unique<ofstream>(path); if (outFile->is_open()) { cout << "[EXPORT] Writing to " << fname << "..." << endl; if (!sameLineCode.empty() && sameLineCode.find_first_not_of(" \t\r\n") != string::npos) { *outFile << sameLineCode << "\n"; } } else { cerr << "[ERROR] Could not open " << fname << " for writing." << endl; outFile.reset(); exportError = true; } } catch (const fs::filesystem_error& e) { cerr << "[ERROR] Filesystem error: " << e.what() << endl; outFile.reset(); exportError = true; } } else { if (outFile && outFile->is_open()) { string cleanContent = stripTemplates(line, insideTemplate); if (!cleanContent.empty()) { *outFile << cleanContent << "\n"; } } else if (!exportError) { remaining += line + "\n"; } } } return remaining; } $$

$$ extractDependencies { set<string> deps; stringstream ss(code); string line; while(getline(ss, line)) { size_t warnPos = line.find("// [WARN] IMPORT NOT FOUND: "); if (warnPos != string::npos) { deps.insert(line.substr(warnPos + 28)); } size_t incPos = line.find("#include"); if (incPos != string::npos) { size_t startQuote = line.find_first_of("\"<", incPos); size_t endQuote = line.find_first_of("\">", startQuote + 1); if (startQuote != string::npos && endQuote != string::npos) { deps.insert(line.substr(startQuote + 1, endQuote - startQuote - 1)); } } } return deps; } $$

$$ preFlightCheck { if (deps.empty()) return true; if (CURRENT_LANG.checkCmd.empty() && CURRENT_LANG.id != "cpp" && CURRENT_LANG.id != "c") return true; cout << "[CHECK] Verifying dependencies locally..." << endl; string tempCheck = "temp_dep_check" + CURRENT_LANG.extension; ofstream out(tempCheck); if (CURRENT_LANG.id == "cpp" || CURRENT_LANG.id == "c") { for(const auto& d : deps) { if (d.find(".h") != string::npos || d.find("/") != string::npos) out << "#include \"" << d << "\"\n"; else out << "#include <" << d << ">\n"; } out << "int main() { return 0; }\n"; } else if (CURRENT_LANG.id == "py") { for(const auto& d : deps) { out << "import " << d << "\n"; } } out.close(); // Additional logic for executing the check and handling results would follow here } $$
$$ preFlightCheck {
    if (deps.empty()) return true;
    if (CURRENT_LANG.checkCmd.empty() && CURRENT_LANG.id != "cpp" && CURRENT_LANG.id != "c") return true;
    $$ verify_dependencies {
        cout << "[CHECK] Verifying dependencies locally..." << endl;
        string tempCheck = "temp_dep_check" + CURRENT_LANG.extension;
        ofstream out(tempCheck);
        $$ generate_check_code {
            if (CURRENT_LANG.id == "cpp" || CURRENT_LANG.id == "c") {
                for(const auto& d : deps) {
                    if (d.find(".h") != string::npos || d.find("/") != string::npos) 
                        out << "#include \"" << d << "\"\n";
                    else 
                        out << "#include <" << d << ">\n";
                }
                out << "int main() { return 0; }\n";
            } else if (CURRENT_LANG.id == "py") {
                for(const auto& d : deps) {
                    out << "import " << d << "\n";
                }
            }
        }
        out.close();
        $$ execute_dependency_check {
            string cmd;
            if (!CURRENT_LANG.checkCmd.empty()) {
                cmd = CURRENT_LANG.checkCmd + " \"" + tempCheck + "\"";
            } else {
                cmd = CURRENT_LANG.buildCmd + " -c \"" + tempCheck + "\""; 
            }
            CmdResult res = execCmd(cmd);
            
            fs::remove(tempCheck);
            if (fs::exists(stripExt(tempCheck) + ".o")) fs::remove(stripExt(tempCheck) + ".o");
            if (fs::exists(stripExt(tempCheck) + ".obj")) fs::remove(stripExt(tempCheck) + ".obj");

            if (res.exitCode != 0) {
                $$ handle_dependency_errors {
                    cout << "   [!] Missing Dependency Detected!" << endl;
                    for(const auto& d : deps) {
                        if (res.output.find(d) != string::npos) {
                            cout << "       -> " << d << " not found." << endl;
                        }
                    }
                    if (isFatalError(res.output)) {
                        cout << "   [?] Analyze fatal error with AI? [y/N]: ";
                        char ans; cin >> ans;
                        if (ans == 'y' || ans == 'Y') explainFatalError(res.output);
                    } else {
                        cout << "   [ERROR LOG]:\n" << res.output.substr(0, 300) << endl;
                    }
                    return false;
                }
            }
            cout << "   [OK] Dependencies verified." << endl;
            return true;
        }
    }
}

$$ selectTarget {
    string label = "Language";
    if (CURRENT_MODE == GenMode::MODEL_3D) label = "3D Format";
    if (CURRENT_MODE == GenMode::IMAGE) label = "Image Format";
    $$ display_selection_menu {
        cout << "\n[?] Ambiguous target. Select " << label << ":\n";
        int i = 1; vector<string> keys;
        
        const auto* db = &LANG_DB;
        if (CURRENT_MODE == GenMode::MODEL_3D) db = &MODEL_DB;
        else if (CURRENT_MODE == GenMode::IMAGE) db = &IMAGE_DB;

        for(auto const& [key, val] : *db) keys.push_back(key);
        for(const auto& k : keys) { cout << i++ << ". " << db->at(k).name << " "; if(i%4==0) cout<<endl;}
        cout << "\n> "; int c; cin >> c; 
    }
    $$ process_selection {
        if(c>=1 && c<=keys.size()) CURRENT_LANG = db->at(keys[c-1]);
        else CURRENT_LANG = (CURRENT_MODE == GenMode::CODE) ? LANG_DB["cpp"] : (CURRENT_MODE == GenMode::MODEL_3D ? MODEL_DB["obj"] : IMAGE_DB["svg"]);
    }
}

$$ splitSourceCode {
    vector<string> chunks;
    stringstream ss(code);
    string line;
    string currentChunk;
    int lineCount = 0;
    int braceBalance = 0;
    $$ process_lines {
        while (getline(ss, line)) {
            currentChunk += line + "\n";
            lineCount++;
            $$ count_braces {
                string trimmed = line;
                size_t start = trimmed.find_first_not_of(" \t");
                if (start != string::npos) trimmed = trimmed.substr(start);
                if (trimmed.find("//") != 0 && trimmed.find("#") != 0) {
                    for (char c : line) {
                        if (c == '{') braceBalance++;
                        else if (c == '}') braceBalance--;
                    }
                }
            }
            $$ check_split_conditions {
                bool safeToSplit = false;
                if (braceBalance <= 0) {
                    if (trimmed.empty()) safeToSplit = true; 
                    else if (line.find_first_not_of(" \t") == 0) safeToSplit = true;
                }
                if ((lineCount >= targetLines && safeToSplit) || lineCount >= targetLines + 200) {
                    chunks.push_back(currentChunk);
                    currentChunk = "";
                    lineCount = 0;
                    braceBalance = 0; 
                }
            }
        }
    }
    if (!currentChunk.empty()) chunks.push_back(currentChunk);
    return chunks;
}

$$ extractSignatures {
    stringstream ss(code);
    string line;
    string result;
    $$ process_lines {
        while (getline(ss, line)) {
            string trimmed = line;
            size_t first = trimmed.find_first_not_of(" \t");
            if (first == string::npos) continue;
            trimmed = trimmed.substr(first);
            $$ filter_comments {
                if (trimmed.find("//") == 0) continue; 
            }
            $$ extract_relevant_lines {
                if (trimmed[0] == '#' || trimmed.find("using ") == 0 || trimmed.find("typedef ") == 0) {
                    result += line + "\n";
                    continue;
                }
                if (trimmed.find("class ") == 0 || trimmed.find("struct ") == 0 || trimmed.find("enum ") == 0 ||
                    (trimmed.find('(') != string::npos && trimmed.find(')') != string::npos)) {
                    result += line + "\n";
                }
            }
        }
    }
    return result;
}

$$ stripMetadata {
    size_t start = code.find("META_START");
    size_t end = code.find("META_END");
    if (start != string::npos && end != string::npos && end > start) {
        return code.substr(0, start) + code.substr(end + 8);
    }
    return code;
}

$$ showMetadata {
    if (!fs::exists(filename)) {
        cout << "[ERROR] File not found: " << filename << endl;
        return;
    }
    ifstream f(filename);
    string content((istreambuf_iterator<char>(f)), istreambuf_iterator<char>());
    f.close();
    $$ extract_metadata {
        size_t start = content.find("META_START");
        size_t end = content.find("META_END");
        json meta;
        bool found = false;
        if (start != string::npos && end != string::npos && end > start) {
            string jsonStr = content.substr(start + 10, end - (start + 10));
            try {
                meta = json::parse(jsonStr);
                found = true;
            } catch (exception& e) {
                cout << "[ERROR] Invalid JSON in META block: " << e.what() << endl;
                return;
            }
        } else {
            meta["name"] = fs::path(filename).stem().string();
            meta["inferred"] = true;
        }
        set<string> deps = extractDependencies(content);
        if (!deps.empty()) meta["dependencies_detected"] = deps;
    }
    $$ display_metadata {
        cout << "\n--- GLUPE METADATA: " << filename << " ---\n";
        cout << meta.dump(4) << endl;
        cout << "-----------------------------------\n";
    }
}

$$ getSession {
    if (!fs::exists(SESSION_FILE)) return {"", ""};
    try {
        ifstream f(SESSION_FILE);
        json j = json::parse(f);
        return {j.value("token", ""), j.value("username", "")};
    } catch (...) {
        return {"", ""};
    }
}

$$ saveSession {
    json j;
    j["token"] = token;
    j["username"] = username;
    ofstream f(SESSION_FILE);
    if (f.is_open()) {
        f << j.dump(4);
        f.close();
        cout << "[SUCCESS] Logged in as " << username << endl;
    } else {
        cout << "[ERROR] Could not save session file." << endl;
    }
}

$$ startInteractiveHub {
    string hub_url = "https://glupehub.up.railway.app";
    cout << "GlupeHub v-alpha-1.0 MVPType 'help' for commands." << endl;
    $$ command_loop {
        while (true) {
            cout << "hub> ";
            string line;
            getline(cin, line);
            if (cin.eof() || line == "exit") {
                break;
            }
            if (line.empty()) {
                continue;
            }
            stringstream ss(line);
            string command;
            ss >> command;
            $$ process_commands {
                if (command == "help") {
                    $$ display_help {
                        cout << "Available commands:\n";
                        cout << "  search <query>   : Search for files by name.\n";
                        cout << "  tag <tagname>    : Search for files by tag.\n";
                        cout << "  show <username>  : Show files for a user.\n";
                        cout << "  view <file_id>   : View file metadata (e.g., user/file.glp).\n";
                        cout << "  pull <file_id>   : Download a file.\n";
                        cout << "  exit             : Exit interactive mode.\n";
                    }
                } else if (command == "search") {
                    $$ handle_search {
                        string query;
                        getline(ss, query);
                        query.erase(0, query.find_first_not_of(" \t"));
                        if (query.empty()) { cout << "Usage: search <query>" << endl; continue; }
                        string curlCmd = "curl -sS -G --data-urlencode \"q=" + query + "\" \"" + hub_url + "/search/files\"";
                        cout << execCmd(curlCmd).output << endl;
                    }
                } else if (command == "tag") {
                    $$ handle_tag {
                        string tag;
                        ss >> tag;
                        if (tag.empty()) { cout << "Usage: tag <tagname>" << endl; continue; }
                        string curlCmd = "curl -sS -G --data-urlencode \"tag=" + tag + "\" \"" + hub_url + "/search/files\"";
                        cout << execCmd(curlCmd).output << endl;
                    }
                } else if (command == "show") {
                    $$ handle_show {
                        string target;
                        ss >> target;
                        if (target.empty()) { cout << "Usage: show <username>" << endl; continue; }
                        string curlCmd = "curl -sS -G --data-urlencode \"author=" + target + "\" \"" + hub_url + "/search/files\"";
                        string response = execCmd(curlCmd).output;
                        $$ process_show_response {
                            try {
                                json j = json::parse(response);
                                const json* files_to_process = nullptr;
                                if (j.is_object() && j.contains("files") && j["files"].is_array()) {
                                    files_to_process = &j["files"];
                                } else if (j.is_array()) {
                                    files_to_process = &j;
                                }
                                if (files_to_process) {
                                    cout << "\n Directory of " << target << "\n\n";
                                    cout << left << setw(30) << "File Name" 
                                         << right << setw(12) << "Size (KB)" 
                                         << "   " << left << "Last Modified" << endl;
                                    cout << string(65, '-') << endl;
                                    for (const auto& item : *files_to_process) {
                                        string name = item.value("filename", "unknown");
                                        long long bytes = item.value<long long>("size", 0);
                                        string date = item.value("created_at", "unknown");
                                        if (date.length() > 10) date = date.substr(0, 10);
                                        double kb = static_cast<double>(bytes) / 1024.0;
                                        cout << left << setw(30) << name 
                                             << right << setw(12) << fixed << setprecision(2) << kb 
                                             << "   " << left << date << endl;
                                    }
                                    cout << "\n              " << files_to_process->size() << " File(s)\n";
                                } else {
                                    cout << response << endl;
                                }
                            } catch (...) {
                                cout << response << endl;
                            }
                        }
                    }
                } else if (command == "view") {
                    $$ handle_view {
                        string file_id;
                        ss >> file_id;
                        if (file_id.empty()) { cout << "Usage: view <file_id>" << endl; continue; }
                        string curlCmd = "curl -sS \"" + hub_url + "/meta/" + file_id + "\"";
                        string response = execCmd(curlCmd).output;
                        $$ process_view_response {
                            try {
                                json j_resp = json::parse(response);
                                if (j_resp.contains("content_preview")) {
                                    string content = j_resp["content_preview"];
                                    size_t start = content.find("META_START");
                                    size_t end = content.find("META_END");
                                    if (start != string::npos && end != string::npos && end > start) {
                                        string metaJsonStr = content.substr(start + 10, end - (start + 10));
                                        try {
                                            json meta = json::parse(metaJsonStr);
                                            $$ display_metadata_table {
                                                size_t maxKeyLen = 5; 
                                                for (auto& el : meta.items()) {
                                                    if (el.key().length() > maxKeyLen) maxKeyLen = el.key().length();
                                                }
                                                size_t maxValueLen = 60;
                                                string border = "+" + string(maxKeyLen + 2, '-') + "+" + string(maxValueLen + 2, '-') + "+";
                                                cout << "\n Metadata for " << file_id << "\n";
                                                cout << border << endl;
                                                cout << "| " << left << setw(maxKeyLen) << "Field" << " | " << setw(maxValueLen) << "Value" << " |" << endl;
                                                cout << border << endl;
                                                for (auto& el : meta.items()) {
                                                    string val;
                                                    if (el.value().is_string()) val = el.value().get<string>();
                                                    else val = el.value().dump();
                                                    if (val.length() > maxValueLen) {
                                                        val = val.substr(0, maxValueLen - 3) + "...";
                                                    }
                                                    cout << "| " << left << setw(maxKeyLen) << el.key() << " | " << setw(maxValueLen) << val << " |" << endl;
                                                }
                                                cout << border << endl;
                                            }
                                        } catch (exception& e) {
                                            cout << "[ERROR] Corrupt metadata block: " << e.what() << endl;
                                        }
                                    } else {
                                        cout << "[INFO] No metadata block found." << endl;
                                    }
                                } else if (j_resp.contains("error")) {
                                    cout << "[ERROR] " << j_resp["error"].get<string>() << endl;
                                } else {
                                    cout << response << endl;
                                }
                            } catch (...) {
                                cout << response << endl;
                            }
                        }
                    }
                } else if (command == "pull") {
                    $$ handle_pull {
                        string file_id;
                        ss >> file_id;
                        if (file_id.empty()) { cout << "Usage: pull <file_id>" << endl; continue; }
                        size_t last_slash_pos = file_id.find_last_of('/');
                        string filename = (last_slash_pos == string::npos) ? file_id : file_id.substr(last_slash_pos + 1);
                        string curlCmd = "curl -sS -L -o \"" + filename + "\" \"" + hub_url + "/pull/" + file_id + "\"";
                        CmdResult res = execCmd(curlCmd);
                        if (res.exitCode == 0) { cout << "[SUCCESS] Saved " << filename << endl; } 
                        else { cout << "[ERROR] Download failed. Server response: " << res.output << endl; }
                    }
                } else {
                    cout << "Unknown command: '" << command << "'. Type 'help' for commands." << endl;
                }
            }
        }
    }
}

$$ main {
    auto startTime = std::chrono::high_resolution_clock::now();
    initLogger(); 
    if (argc < 2) {
        $$ display_usage {
            cout << "GLUPE v" << CURRENT_VERSION << " (Multi-File)\nUsage: glupe file1 ... [-o output] [-cloud/-local] [-3d/-img] [-u] \"*Custom Instructions\"" << endl;
            cout << "Commands:\n  config <key> <val> : Update config.json\n  config model-local : Detect installed Ollama models\n";
            cout << "  clean cache        : Clear semantic cache\n";
            cout << "  fix <file> \"desc\"  : AI-powered code repair\n";
            cout << "  explain <file> [lg] : Generate commented documentation\n";
            cout << "  diff <f1> <f2> [lg] : Generate semantic diff report\n";
            cout << "  sos [lang] \"error\" : Ask AI for help on error/problem (no file needed)\n";
            cout << "  info <file.glp>    : Show metadata for GlupeHub\n";
            cout << "  insert-metadata <path> : Insert metadata template\n";
            cout << "  login [url]        : Authenticate with GlupeHub\n";
            cout << "  logout             : Log out from GlupeHub\n";
            cout << "  whoami             : Show current user\n";
            cout << "  push <file> [tags] : Upload file to GlupeHub (requires login)\n";
            cout << "  hub                : Enter interactive hub mode\n";
            cout << "  pull <file> <user> : Download file from GlupeHub\n";
        }
        return 0;
    }
    $$ handle_commands {
        string cmd = argv[1];
        if (cmd == "config") {
            $$ handle_config {
                if (argc < 3) {
                    cout << "Usage: glupe config <key> <value>\n";
                    cout << "       glupe config see\n";
                    cout << "       glupe config model-local (Interactive selection)\n\n";
                    cout << "Keys:\n";
                    cout << "  api-key         : Set Cloud API Key\n";
                    cout << "  max-retries     : Set Max Retries (Default: 15)\n";
                    cout << "  cloud-protocol  : Set protocol ('openai', 'google', 'ollama')\n";
                    cout << "  model-cloud     : Set Cloud Model ID\n";
                    cout << "  url-cloud       : Set Cloud API URL\n";
                    cout << "  model-local     : Set Local Model ID\n";
                    cout << "  url-local       : Set Local API URL\n";
                    return 1;
                }
                string key = argv[2];
                if (key == "see") {
                    showConfig();
                    return 0;
                }
                if (key == "model-local" && argc == 3) {
                    selectOllamaModel();
                    return 0;
                }
                if (argc < 4) {
                    cout << "[ERROR] Missing value for key: " << key << endl;
                    return 1;
                }
                updateConfigFile(key, argv[3]);
                return 0;
            }
        }
        if (cmd == "clean") {
            $$ handle_clean {
                if (argc >= 3 && string(argv[2]) == "cache") {
                    cout << "[CLEAN] Removing cache directory (" << CACHE_DIR << ")..." << endl;
                    try {
                        if (fs::exists(CACHE_DIR)) fs::remove_all(CACHE_DIR);
                        if (fs::exists(LOCK_FILE)) fs::remove(LOCK_FILE);
                        cout << "[SUCCESS] Cache cleaned." << endl;
                    } catch (const fs::filesystem_error& e) {
                        cerr << "[ERROR] Failed to clean cache: " << e.what() << endl;
                        return 1;
                    }
                    return 0;
                }
                cout << "Usage: glupe clean cache" << endl;
                return 1;
            }
        }
        if (cmd == "fix") {
            $$ handle_fix {
                if (argc < 4) {
                    cout << "Usage: glupe fix <file> \"instruction\" [-cloud/-local]" << endl;
                    return 1;
                }
                string targetFile = argv[2];
                string instruction = argv[3];
                string mode = "local"; 
                for(int i=4; i<argc; i++) {
                    string arg = argv[i];
                    if (arg == "-cloud") mode = "cloud";
                    else if (arg == "-local") mode = "local";
                }
                if (!loadConfig(mode)) return 1;
                if (!fs::exists(targetFile)) {
                    cout << "[ERROR] File not found: " << targetFile << endl;
                    return 1;
                }
                cout << "[FIX] Reading " << targetFile << "..." << endl;
                ifstream f(targetFile);
                string content((istreambuf_iterator<char>(f)), istreambuf_iterator<char>());
                f.close();
                string ext = getExt(targetFile);
                string langName = "Code";
                for(auto const& [key, val] : LANG_DB) {
                    if(val.extension == ext) { langName = val.name; break; }
                }
                cout << "[AI] Applying fix (" << mode << ")..." << endl;
                stringstream prompt;
                prompt << "ROLE: Expert " << langName << " developer.\n";
                prompt << "TASK: Fix the code based on the instruction.\n";
                prompt << "INSTRUCTION: " << instruction << "\n";
                prompt << "CODE:\n" << content << "\n";
                prompt << "OUTPUT: Return ONLY the fixed code. No markdown. No explanations.";
                string response = callAI(prompt.str());
                string fixedCode = extractCode(response);
                if (fixedCode.find("ERROR:") == 0) {
                    cout << "   [!] API Error: " << fixedCode.substr(6) << endl;
                    return 1;
                }
                ofstream out(targetFile);
                out << fixedCode;
                out.close();
                cout << "[SUCCESS] File updated: " << targetFile << endl;
                return 0;
            }
        }
    }
}
$$ sos_command {
    if (cmd == "sos") {
        $$ validate_args {
            if (argc < 3) {
                cout << "Usage: glupe sos [language] [-cloud/-local] \"error or problem description\"" << endl;
                return 1;
            }
        }
        
        $$ parse_args {
            string language = "General Programming";
            string query = "";
            string mode = "local";

            for (int i = 2; i < argc; i++) {
                string arg = argv[i];
                if (arg == "-cloud") mode = "cloud";
                else if (arg == "-local") mode = "local";
                else if (i == argc - 1) query = arg;
                else language = arg;
            }

            if (query.empty()) {
                cout << "[ERROR] Please provide a problem description or error message." << endl;
                return 1;
            }

            if (!loadConfig(mode)) return 1;
        }

        $$ generate_prompt {
            cout << "[SOS] Consulting AI (" << mode << ") about " << language << "..." << endl;
            
            stringstream prompt;
            prompt << "ROLE: Senior Software Architect & Technical Lead.\n";
            prompt << "TASK: Provide a clear, concise, and accurate solution for the user's problem.\n";
            prompt << "CONTEXT/LANGUAGE: " << language << "\n";
            prompt << "USER PROBLEM: " << query << "\n";
            prompt << "OUTPUT: Markdown formatted response. Be helpful and direct. Provide code snippets if necessary.";
        }

        $$ call_ai {
            string response = callAI(prompt.str());
        }

        $$ parse_response {
            string answer = response;
            try {
                json j = json::parse(response);
                if (j.contains("choices") && !j["choices"].empty()) {
                    if (j["choices"][0].contains("message")) answer = j["choices"][0]["message"]["content"];
                    else if (j["choices"][0].contains("text")) answer = j["choices"][0]["text"];
                }
                else if (j.contains("candidates") && !j["candidates"].empty()) {
                    answer = j["candidates"][0]["content"]["parts"][0]["text"];
                }
                else if (j.contains("response")) answer = j["response"];
            } catch(...) {
                // Use raw response if parsing fails
            }
        }

        $$ display_response {
            cout << "\n--- GLUPE SOS REPLY ---\n";
            cout << answer << endl;
            cout << "----------------------\n";
            return 0;
        }
    }
} $$

$$ explain_command {
    if (cmd == "explain") {
        $$ validate_args {
            if (argc < 3) {
                cout << "Usage: glupe explain <file> [-cloud/-local] [language]" << endl;
                return 1;
            }
        }

        $$ parse_args {
            string targetFile = argv[2];
            string mode = "local"; 
            string language = "English";

            for(int i=3; i<argc; i++) {
                string arg = argv[i];
                if (arg == "-cloud") mode = "cloud";
                else if (arg == "-local") mode = "local";
                else language = arg;
            }

            if (!loadConfig(mode)) return 1;
        }

        $$ validate_file {
            if (!fs::exists(targetFile)) {
                cout << "[ERROR] File not found: " << targetFile << endl;
                return 1;
            }
        }

        $$ read_file {
            cout << "[EXPLAIN] Reading " << targetFile << "..." << endl;
            ifstream f(targetFile);
            string content((istreambuf_iterator<char>(f)), istreambuf_iterator<char>());
            f.close();
        }

        $$ generate_prompt {
            cout << "[AI] Generating documentation in " << language << " (" << mode << ")..." << endl;
            stringstream prompt;
            prompt << "TASK: Add high-quality technical documentation comments to the provided code in " << language << ".\n";
            prompt << "STRICT RULES:\n";
            prompt << "1. RETURN THE FULL SOURCE CODE exactly as provided but with added comments.\n";
            prompt << "2. DO NOT simplify the code. DO NOT replace it with examples like 'Hello World'.\n";
            prompt << "3. Use the language's standard comment syntax.\n";
            prompt << "4. Document functions, logic blocks, and variables.\n";
            prompt << "5. Ensure all comments are written in " << language << ".\n";
            prompt << "6. Return ONLY the code in a markdown block.\n\n";
            prompt << "CODE TO DOCUMENT:\n" << content;
        }

        $$ call_ai {
            string response = callAI(prompt.str());
        }

        $$ process_response {
            string docCode = extractCode(response);

            if (docCode.find("ERROR:") == 0) {
                cout << "   [!] API Error: " << docCode.substr(6) << endl;
                return 1;
            }
        }

        $$ save_output {
            string ext = getExt(targetFile);
            string docFile = stripExt(targetFile) + "_doc" + ext;
            
            ofstream out(docFile);
            out << docCode;
            out.close();
            
            cout << "[SUCCESS] Documentation generated: " << docFile << endl;
            return 0;
        }
    }
} $$

$$ diff_command {
    if (cmd == "diff") {
        $$ validate_args {
            if (argc < 4) {
                cout << "Usage: glupe diff <fileA> <fileB> [-cloud/-local] [language]" << endl;
                return 1;
            }
        }

        $$ parse_args {
            string fileA = argv[2];
            string fileB = argv[3];
            string mode = "local";
            string language = "English";

            for(int i=4; i<argc; i++) {
                string arg = argv[i];
                if (arg == "-cloud") mode = "cloud";
                else if (arg == "-local") mode = "local";
                else language = arg;
            }

            if (!loadConfig(mode)) return 1;
        }

        $$ validate_files {
            if (!fs::exists(fileA) || !fs::exists(fileB)) {
                cout << "[ERROR] One or both files not found." << endl;
                return 1;
            }
        }

        $$ read_files {
            cout << "[DIFF] Comparing " << fileA << " vs " << fileB << "..." << endl;
            
            ifstream fa(fileA), fb(fileB);
            string contentA((istreambuf_iterator<char>(fa)), istreambuf_iterator<char>());
            string contentB((istreambuf_iterator<char>(fb)), istreambuf_iterator<char>());
            fa.close(); fb.close();
        }

        $$ generate_prompt {
            stringstream prompt;
            prompt << "ROLE: Expert Software Auditor.\n";
            prompt << "TASK: Compare two source files and generate a semantic diff report in " << language << ".\n";
            prompt << "REPORT FORMAT:\n";
            prompt << "1. Brief Summary of changes.\n";
            prompt << "2. Changed Functions (What changed and where).\n";
            prompt << "3. Additional Observations (Potential bugs, improvements).\n";
            prompt << "RETURN: Only the report in Markdown format.\n\n";
            prompt << "--- FILE A (" << fileA << ") ---\n" << contentA << "\n";
            prompt << "\n--- FILE B (" << fileB << ") ---\n" << contentB << "\n";
        }

        $$ call_ai {
            cout << "[AI] Analyzing changes (" << mode << ")..." << endl;
            string res = callAI(prompt.str());
        }

        $$ process_response {
            string report = res;
            try {
                json j = json::parse(res);
                if (j.contains("choices")) report = j["choices"][0]["message"]["content"];
                else if (j.contains("candidates")) report = j["candidates"][0]["content"]["parts"][0]["text"];
                else if (j.contains("response")) report = j["response"];
            } catch(...) {}
        }

        $$ save_report {
            string outName = fs::path(fileA).stem().string() + "_" + fs::path(fileB).stem().string() + "_diff_report.md";
            ofstream out(outName);
            out << report;
            out.close();

            cout << "[SUCCESS] Report generated: " << outName << endl;
            return 0;
        }
    }
} $$

$$ refine_mode {
    if (refineMode) {
        $$ process_files {
            for (const auto& file : inputFiles) {
                cout << "[REFINE] Processing " << file << "..." << endl;
                
                $$ validate_file {
                    if (!fs::exists(file)) {
                        cout << "[ERROR] File not found: " << file << endl;
                        continue;
                    }
                }

                $$ read_file {
                    ifstream f(file);
                    string content((istreambuf_iterator<char>(f)), istreambuf_iterator<char>());
                    f.close();
                }

                $$ split_code {
                    vector<string> chunks = splitSourceCode(content);
                }

                $$ refine_chunks {
                    string fullRefinedCode = "";
                    string previousContext = "";

                    cout << "[AI] Semantic compression (" << mode << ") - " << chunks.size() << " chunks..." << endl;

                    for (size_t i = 0; i < chunks.size(); ++i) {
                        cout << "   -> Processing chunk " << (i + 1) << "/" << chunks.size() << "..." << endl;
                        
                        $$ generate_prompt {
                            stringstream prompt;
                            prompt << "ROLE: Senior Systems Engineer & Logic Architect.\n";
                            prompt << "TASK: Transpile Source Code into a High-Fidelity Semantic Blueprint (.glp).\n";
                            prompt << "GOAL: Destill the implementation into functional blocks $$ name { logic } $$ while KEEPING the external interface intact.\n";

                            if (i > 0) {
                                prompt << "\n[EXTERNAL_CONTEXT_FROM_PREVIOUS_PARTS]\n";
                                prompt << "Existing Signatures/Globals: " << extractSignatures(previousContext) << "\n";
                                prompt << "Maintain strict compatibility with these definitions.\n";
                            }

                            prompt << "\n[STRICT_RULES]\n";
                            prompt << "1. DO NOT SUMMARIZE. Rewrite the logic inside blocks using pseudocode or technical steps.\n";
                            prompt << "2. KEEP ALL function signatures (return type, name, params) OUTSIDE the blocks.\n";
                            prompt << "3. REPLACE ONLY the curly-brace bodies { ... } with semantic blocks $$ block_name { ... } $$.\n";
                            prompt << "4. PRESERVE all #include, constants, and global variable declarations exactly as they are.\n";
                            prompt << "5. Return ONLY the .glp fragment for this part. No conversation. No markdown code blocks.\n";

                            prompt << "\n[SOURCE_CODE_PART_" << (i+1) << "]\n";
                            prompt << chunks[i] << "\n";
                        }

                        $$ call_ai_with_retry {
                            string refinedChunk;
                            bool success = false;
                            int retries = 0;

                            while (retries < MAX_RETRIES) {
                                string response = callAI(prompt.str());
                                refinedChunk = extractCode(response);

                                if (refinedChunk.find("ERROR:") == 0) {
                                    // Handle API errors and retry
                                } else {
                                    success = true;
                                    break;
                                }
                            }

                            if (!success) {
                                cout << "   [FATAL] Failed to refine chunk " << (i+1) << " after " << MAX_RETRIES << " attempts. Aborting operation." << endl;
                                return 1;
                            }
                        }

                        $$ update_context {
                            fullRefinedCode += refinedChunk + "\n";
                            previousContext = refinedChunk;
                        }
                    }
                }

                $$ save_output {
                    string outputFile = file + ".glp";
                    ofstream out(outputFile);
                    out << fullRefinedCode;
                    out.close();

                    cout << "[SUCCESS] Semantic file generated: " << outputFile << endl;
                }
            }
        }
        return 0;
    }
} $$
$$ determine_output_language {
    if (!explicitLang) {
        if (outputName.empty()) {
            CURRENT_LANG = (CURRENT_MODE == GenMode::CODE) ? 
                          LANG_DB["cpp"] : 
                          (CURRENT_MODE == GenMode::MODEL_3D ? 
                           MODEL_DB["obj"] : 
                           IMAGE_DB["svg"]);
        } else {
            string ext = getExt(outputName);
            bool found = false;
            
            // Check language databases for matching extension
            auto check_db = [&](const auto& db) {
                for (const auto& [key, val] : db) {
                    if (val.extension == ext) {
                        CURRENT_LANG = val;
                        explicitLang = true;
                        found = true;
                        CURRENT_MODE = (db == LANG_DB) ? GenMode::CODE : 
                                      (db == MODEL_DB) ? GenMode::MODEL_3D : 
                                                        GenMode::IMAGE;
                        return true;
                    }
                }
                return false;
            };
            
            check_db(LANG_DB) || check_db(MODEL_DB) || check_db(IMAGE_DB);
            
            if (!explicitLang) selectTarget();
        }
    }
} $$

$$ generate_output_name {
    if (outputName.empty()) {
        string baseName = stripExt(inputFiles[0]);
        
        if (CURRENT_LANG.producesBinary && !transpileMode) {
            #ifdef _WIN32
            outputName = baseName + ".exe";
            #else
            outputName = baseName;
            #endif
        } else {
            outputName = baseName + CURRENT_LANG.extension;
        }
    }
} $$

$$ verify_toolchain {
    if (CURRENT_MODE == GenMode::CODE) {
        cout << "[CHECK] Toolchain for " << CURRENT_LANG.name << "..." << endl;
        
        if (CURRENT_LANG.versionCmd.empty()) {
            cout << "   [INFO] No toolchain required." << endl;
        } else {
            CmdResult res = execCmd(CURRENT_LANG.versionCmd);
            if (res.exitCode != 0) {
                cout << "   [!] Toolchain not found (" << CURRENT_LANG.versionCmd << "). Blind Mode." << endl;
            } else {
                cout << "   [OK] Ready." << endl;
            }
        }
    }
} $$

$$ process_input_files {
    aggregatedContext = "";
    loadedInputs.clear();
    
    for (const auto& file : inputFiles) {
        fs::path p(file);
        if (!fs::exists(p)) {
            cerr << "Error: File not found: " << file << endl;
            return 1;
        }
        
        ifstream f(p);
        string raw((istreambuf_iterator<char>(f)), istreambuf_iterator<char>());
        f.close();
        
        string cleanRaw = stripMetadata(raw);
        string resolved = resolveImports(cleanRaw, p.parent_path(), stack);
        
        if (resolved.find("EXPORT:") != string::npos && !makeMode && !seriesMode) {
            cout << "[INFO] 'EXPORT:' directive detected. Auto-enabling Architect Mode (-make)." << endl;
            makeMode = true;
        }
        
        loadedInputs.push_back({resolved, p.parent_path()});
        
        aggregatedContext += "\n// --- START FILE: " + file + " ---\n";
        aggregatedContext += resolved;
        aggregatedContext += "\n// --- END FILE: " + file + " ---\n";
    }
} $$

$$ validate_and_export {
    if (!validateContainers(aggregatedContext)) return 1;
    
    for (const auto& data : loadedInputs) {
        processExports(data.content, data.path);
    }
} $$

$$ handle_caching {
    initCache();
    
    size_t currentHash = hash<string>{}(
        aggregatedContext + 
        CURRENT_LANG.id + 
        MODEL_ID + 
        (updateMode ? "u" : "n") + 
        customInstructions
    );
    
    string cacheFile = ".glupe_build.cache";
    
    if (!updateMode && !dryRun && 
        fs::exists(cacheFile) && 
        fs::exists(outputName)) {
        
        ifstream cFile(cacheFile);
        size_t storedHash;
        
        if (cFile >> storedHash && storedHash == currentHash) {
            cout << "[CACHE] No changes detected. Using existing build." << endl;
            
            if (runOutput) {
                #ifdef _WIN32
                system(outputName.c_str());
                #else
                string cmd = "./" + outputName; 
                system(cmd.c_str());
                #endif
            }
            return 0;
        }
    }
} $$

$$ preflight_check {
    set<string> potentialDeps = extractDependencies(aggregatedContext);
    if (!preFlightCheck(potentialDeps)) return 1;
} $$

$$ process_with_cache {
    aggregatedContext = processInputWithCache(
        aggregatedContext, 
        updateMode, 
        updateTargets
    );
} $$

$$ handle_series_mode {
    if (seriesMode) {
        auto blueprint = parseBlueprint(aggregatedContext);
        
        if (blueprint.empty()) {
            cout << "[WARN] No EXPORT blocks found for series mode." << endl;
            return 0;
        }
        
        // Series generation logic...
    }
} $$

$$ generate_code {
    string existingCode;
    if (updateMode) {
        string srcPath = stripExt(outputName) + CURRENT_LANG.extension;
        if (fs::exists(srcPath)) {
            ifstream old(srcPath);
            existingCode.assign((istreambuf_iterator<char>(old)), istreambuf_iterator<char>());
            old.close();
        }
    }

    if (dryRun) {
        cout << "--- CONTEXT PREVIEW ---\n" << aggregatedContext << endl;
        return 0;
    }

    // Main generation loop...
} $$

$$ direct_compilation {
    bool canDirectCompile = false;
    
    // Check conditions for direct compilation...
    
    if (canDirectCompile) {
        // Attempt direct compilation...
    }
} $$

$$ ai_generation_loop {
    for(int gen=1; gen<=passes; gen++) {
        // Prepare prompt...
        
        // AI interaction loop...
        
        // Post-processing and validation...
    }
} $$
$$ handle_build_failure {
    log_error("Failed to build after " + to_string(passes) + " attempts.");
    return_exit_code(1);
} $$
