# FOR 5.9
## -Add tree sitter parsing for -refine modelo
Justification:
AI is good at filling gaps, not at creating from scratch. Currently refine mode is buggy since it's 100% AI-generated.

Problems with current AI-only approach:
- Forgets to close containers (missing $$ or $)
- Creates multiline inline containers ($ \n $) → syntax error
- Attempts nested containers ($${ $${} $$ }) → not allowed
- Loses function signatures and structure
- Hallucinates imports/dependencies
- Inconsistent with comment syntax across languages

Solution with Tree-sitter:
- Deterministically parse source code into AST
- Extract exact structure (functions, classes, signatures)
- Generate valid .glp skeleton with placeholders
- Preserve ALL original structure perfectly
- Let AI ONLY fill intent descriptions inside containers

Benefits:
- Zero syntax errors in generated .glp
- Perfect preservation of original code
- Faster refinement (less AI work)
- More reliable (deterministic parts never fail)
- Scales to 40+ languages (Tree-sitter supports them)

Implementation plan:
1. Integrate Tree-sitter with C++ wrapper
2. Start with 5 languages (C++, Python, JS, Rust, Go)
3. Build structure extractor
4. Create skeleton generator
5. AI only writes intent, not code structure
6. Validate output with Tree-sitter again
7. Add languages gradually, AI is good at filling gaps not at making from scratch, currently refine is buggy since it is 100% AI generated. 

## embedded glupe support [DONE]

Just as Krzysztof suggested, the glupe syntax breaks intellisense and syntax highlight for actual IDEs $${}$$ ${}$ instead we could add
```cpp
/* $$ container_name {
intent goes here
} $$
*/

//$ { intent goes here} $
```
Example hybrid program that does not brake IS or SH:
```cpp
#include <iostream>

//$ABSTRACT condition { all printed messages must end with "!"} $

int main(){
    /* $$ main{
        print numbers from 1 to 10
    } $$*/
    //$ second -> condition {print hello} $ 
}

```

have two syntaxes, one for pure glp files (the standard $${}$$) and one for embedded files, so DX is smoother and adoption is easier.

## Time stamp detection

If someone hotfixes the output file at 2 am the intent and the generated cpp will diverge, and that drift tends to become larger and larger.

Idea: Make-like timestamp detection. 

Idea 2: -refine modified output file 


## 