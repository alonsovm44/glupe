# Glupe Language Specification v5.8.1

**Version:** 5.8.1  
**Date:** February 25, 2026  
**Status:** Active

## 1. Introduction

Glupe is a semantic metaprogramming language that allows developers to embed natural language intent, architectural blueprints, and logic containers directly into source code. It operates as a meta-layer above traditional programming languages (C++, Python, etc.), transpiling semantic blocks into concrete code using Large Language Models (LLMs).

This specification defines the syntax and behavior of Glupe containers, directives, and project structure.

## 2. File Extensions

*   **.glp**: Standard Glupe source file.
*   **.glupe**: Alternative extension.
*   **Host Languages**: Glupe syntax can be embedded in any text file (e.g., `.cpp`, `.py`, `.md`) provided the syntax does not conflict with the host language.

## 3. Semantic Containers

Semantic containers are the core primitive of Glupe. They isolate logic to be generated by the AI.

### 3.1 Block Containers

Used for multi-line logic.

**Syntax:**
```glupe
$$ [ABSTRACT] [identifier] [-> parent1, parent2...] {
    <natural language or pseudo-code instructions>
}$$
```

**Examples:**

*Anonymous Block:*
```glupe
$$ {
    Sort the vector 'v' using a custom lambda for descending order.
}$$
```

*Named Block:*
```glupe
$$ "init_system" {
    Initialize the serial port at 9600 baud.
}$$
```

### 3.2 Inline Containers

Used for single-line logic. Must be opened and closed on the same line.

**Syntax:**
```glupe
$ [identifier] [-> parent...] { <instructions> } $
```

**Example:**
```glupe
int result = $ { calculate factorial of n } $;
```

### 3.3 Abstract Containers

Abstract containers define logic or rules that are not generated immediately but are intended to be inherited by other containers. They act as templates or style guides.

**Syntax:**
```glupe
$$ABSTRACT "security_policy" {
    1. Always validate input.
    2. Use parameterized queries.
}$$
```

### 3.4 Embedded Containers

Glupe parses containers inside comments for languages supporting `//` or `/* */`. This allows Glupe logic to exist within valid host code without breaking syntax highlighting or native compilation (until processed).

**Example:**
```cpp
// $$ "refactor_me" { optimize this loop }$$
for(int i=0; i<100; i++) { ... }
```

## 4. Inheritance System

Containers can inherit logic from other named containers. This promotes reusability of prompts and architectural constraints.

**Syntax:**
```glupe
$$ child_id -> parent_id { ... }$$
```

**Multiple Inheritance:**
```glupe
$$ child_id -> parent1, parent2 { ... }$$
```

**Resolution Rules:**
1.  **Override**: Child logic takes precedence over parent logic.
2.  **Order**: In multiple inheritance, parents are resolved left-to-right. If parents contradict, the last listed parent takes precedence (closest to the child).
3.  **Context**: The AI receives the aggregated logic of all parents plus the child.

## 5. Project Architecture (Architect Mode)

Glupe supports defining multi-file projects within a single `.glp` blueprint using `EXPORT` directives.

### 5.1 EXPORT Directive

Defines the content of a specific output file.

**Syntax:**
```glupe
EXPORT: "filename.ext"
    <content>
EXPORT: END
```

**Behavior:**
*   Content inside the block is written to `filename.ext`.
*   Directories in the path are created automatically.
*   Content *outside* EXPORT blocks is treated as global context/instructions for the AI but is not written to disk.

### 5.2 IMPORT Directive

Includes the content of another Glupe file.

**Syntax:**
```glupe
IMPORT: "filename.glp"
```

**Block Import (v5.8.1):**
Allows importing a file and appending local modifications to its context.

```glupe
IMPORT: "filename.glp"
    <local modifications or overrides>
IMPORT: END
```

**Behavior:**
*   Imports are resolved recursively.
*   Circular imports are detected and blocked.

## 6. Meta-Programming Features

### 6.1 Caching

Glupe uses a lockfile (`.glupe.lock`) and a cache directory (`glupe_cache/`) to store the output of named containers.

*   **Hashing**: Containers are hashed based on their prompt content and inheritance chain.
*   **Update Mode (`-u`)**: When running in update mode, Glupe checks the hash. If it matches, the cached code is injected, bypassing the LLM.
*   **Markers**: Generated code is wrapped in `// GLUPE_BLOCK_START: id` and `// GLUPE_BLOCK_END: id` to facilitate cache extraction.

### 6.2 Tree Shaking

Glupe can optimize generated code by removing unused functions and variables while preserving the `main` entry point and `EXPORT` structures.

*   **Trigger**: Automatic in specific modes or via prompt instructions.

## 7. Command Line Integration

While not part of the syntax, these flags control how the language is processed:

*   **-make**: Enables Architect Mode (processes EXPORT blocks).
*   **-series**: Generates EXPORT blocks sequentially to maintain context and prevent token limit errors.
*   **-refine**: Reverse-engineers existing source code into a `.glp` blueprint.
*   **-3d / -img**: Changes the generation mode to 3D models or Images.

## 8. Example Blueprint

```glupe
INTENT: "A simple calculator app"

$$ABSTRACT "math_ops" {
    Ensure all operations handle division by zero gracefully.
    Use double precision.
}$$

EXPORT: "math_lib.h"
    class Calculator {
    public:
        $$ "calc_methods" -> "math_ops" {
            define add, sub, mul, div methods
        }$$
    };
EXPORT: END

EXPORT: "main.cpp"
    #include "math_lib.h"
    int main() {
        $$ { instantiate calculator and run a demo }$$
    }
EXPORT: END
```